☆메모리의구조
1. class영역 = static영역 = final영역 = 인스턴스메서드영역      

2. Stack 영역  : 기본자료형은 값을 stack영역에 저장   

3. Heap 영역  : 참조자료형은 값을 heap영역에 저장  
	(값은 힙영역에있지만 직접 접근할 수 없어 번지수를 가지는 변수를 stack영역에 저장)

		◇stack메모리에서는 강제초기화 되지 않음 빈상태로 있음 
		◇heap메모리에서는 강제초기화 됨 각 참조형의 default값 들어감

========================================================================================================================================================================================================

◇배열의 정렬 : 오름차순 정렬
	int[] arr = { 3, 2, 0, 1, 4 };
	Arrays.sort(arr);
	System.out.println(Arrays.toString(arr7));     [0,1,2,3,4]

◇배열에 특화된 for each문
for (int i : arr) { 
			System.out.print(i+" "); }

        ..............................................................................

◇for문 두개의 변수도 가능
		for (int i = 0, j = 0; i < 10; i++, j++) {
			System.out.print(i + j + " ");
		}
 
◇for문 무한루프 : 조건식이 없면 항상 true값임 문이 열려져있다고 보면 됨
		
		 for (int i = 0 ; ; i++) { System.out.println(i); }
		 
		 for ( ; ; ) { System.out.println(); }
		 
========================================================================================================================================================================================================

		다른 참조자료형과 다른게 string만 가지고있는 특징
		
		◇객체 내의 값 변경 불가능
		
		String str1 = "안녕";
		String str2 = str1;
		str1 = "안녕하세요";
		
		System.out.println(str1);
		System.out.println(str2);
		만약 값이 변경된다면 새로운 객체를 생성하게됨 - 새로운 주소를 만들음
		
		같은 참조자료형인 배열과 비교해보자
		int[] arr1 = {1,2,3};
		int[] arr2 = arr1;
		arr2[0] = 4;
		
		System.out.println(Arrays.toString(arr1)); //[4,2,3]
		System.out.println(Arrays.toString(arr2)); //[4,2,3]
		같은 주소를 참조하기에 값이 똑같다
		String 만이 참조자료형중 유일하게 객체 내의 값 변경 불가능

========================================================================================================================================================================================================

☆자바에서 제공하는 객체지향 요소     :    1.클래스    2.인터페이스
		클래스는 일반클래스|추상클래스로 나뉠수 있고 클래스 파일안에 abstract가 붙여져 있으면 모두 추상클래스이다   (abstract void abc(); 추상메서드 중괄호없음)
        ..............................................................................
		◇클래스 안에 올 수 있는 4가지      밖에 올 수 있는 3가지
				◇밖 
					1.패키지                          	 : .java 파일의 폴더위치
 					2.import                        	 :	다른 폴더(패키지) 위치의 클래스를 참조
					3.외부클래스(external class)  : 같은 파일 내에 public을 사용할 수 없는 클래스
				◇안
					1.필드                              : 클래스 특징(속성)을 나타내는 변수    (메서드 안에있는 변수는 지역변수이므로 다르다)      [멤버]
					2.메서드							 : 클래스의 기능																					  [멤버]
					3.생성자							 : 객체 생성 기능   - 클래스랑 이름이 반드시 동일해야함
					4.이너클래스						 : 클래스 내부에 정의된 클래스																      [멤버]
        ..............................................................................
		
			A 				a 				= 					new 					A();      //붕어빵을 만듬
		  클래스         참조변수 							힙메모리에 넣어라          생성자
		생성자를 통해서 나온 객체를 new에 의해서 힙메모리에 집어넣고 그 위치를 참조변수 a에 집어넣어라 
		객체 생성됨 이제 사용 가능  [ 참조변수. ] 을 사용해서 이용한다
      
		..............................................................................
		
		필드와 지역변수
				◇heap : 힙에 들어가는 필드값은 값을 미입력시 강제 초기화됨  =   숫자는 0 , 논리는 false  , 참조는 null
				◇stack	: 스택에 들어가는 지역변수는 강제 초기화 되지 않음   =   에러
		
		class B {
			◇선언만 한 필드 m,n
			int m; 	 //힙
			int n;	 //힙
			boolean l;
		}
			
			void work1() {
				◇선언만 한 지역변수 k
				◇초기값이 없는 상태로 출력시도하면 에러  
				◇이곳에 m,n은 문제안됨 0 출력함		
				int k;  //스택
				System.out.println(l);
				System.out.println(k);}

========================================================================================================================================================================================================

void 타입의 메서드가 return이 있을경우 메서드를 끝내겠다는 뜻!

◇멤버(필드,메서드,이너클래스)의 접근지정자
	
	public      : 동일 패키지의 모든 클래스 + 다른 패키지의 모든 클래스 사용가능
	
	protected   : 동일 패키지의 모든 클래스 + 다른패키지의 [자식] 클래스에서 사용가능
	
	default	  : 동일 패키지의 모든 클래스에서 사용가능  = 내 패키지에서만 사용가능
	
	private     : 자신 클래스내에서만 사용가능
	
	        ..............................................................................
	
◇클래스의 접근지정자
	
	public      : 다른 패키지에서 import 가능
	
	default     : 다른 패키지에서 import 불가능
	                동일 패키지내에서 객체 생성 가능
	
	        ..............................................................................
	
◇생성자의 접근 지정자 = 클래스의 접근지정자와 동일
	
	public   ,   default
	클래스가 import가 가능하다면 생성자도 가능 그러나 생성자가 default가 아닐시
	
	public 클래스의 [자동추가]생성자는 public생성자
	default클래스의 [자동추가]생성자는 default생성자
	
	public클래스의 default생성자는 다른패키지에서 import를 할 수 있지만 객체생성 불가능
	A a = new A();

========================================================================================================================================================================================================

☆다운캐스팅
		
		A <- B <- C
		       ↑       
			   D
		
		A a = new A() 는 객체를                         
		A까지 만들었기 때문에 A까지 이용가능
		B,C,D는 이용 불가능												타입변환:x
		
		A a = new B() 는 객체를                         
		B까지 만들었기 때문에 캐스팅을 한다면 A,B까지 이용가능        타입변환:o
		C,D는 이용 불가능													타입변환:x
		지금은 a로 만들었기 때문에 a번지를 가리킴 하지만 캐스팅한다면
		B까지 이용가능
		 
		A a = new C() 는 객체를                        
		C까지 만들었기 때문에 캐스팅을 한다면 A,B,C까지 이용 가능   타입변환:o
		D는 이용 불가능                                                    타입변환:x
		지금은 a로 만들었기 때문에 a번지를 가리킴 하지만 캐스팅한다면
		B,C까지 이용가능

========================================================================================================================================================================================================

☆ 메서드 오버로딩과 오버라이딩의 차이점
		오버로딩 : 메서드명은 같지만 시그니처가 달라서 같은공간 다른 메서드처럼 존재가능
		오버라이딩 : 메서드명,시그니처가 완전히 같아서 덮어쓰기 하는것

☆ 오버라이딩(overriding)    과    구현하기(implements)의 차이점
		오버라이딩 : 부모클래스의 메서드(완성,미완성)를 자식클래스에서 재정의(완성시킴)
		구현하기   : 부모클래스의 [추상(미완성)메서드]를 자식클래스에서 재정의(완성시킴)
									즉 구현하기는 오버라이딩에 포함되어있다

☆오버라이딩과 구현하기(implements)의 차이점
	오버라이딩 : 부모클래스의 완성/미완성 메서드를 자식클래스에서 완성함
	구현하기   : 부모클래스의 미완성메서드(추상메서드)를 자식클래스에서 완성
	     ◇중괄호의 유무에 따라 완성 미완성 구분


☆ 인스턴스멤버 와 static멤버 오버라이딩 정리
	
	 instance 필드 : 오버라이딩 불가능
	 static 필드   : 오버라이딩 불가능
	 static 메서드 : 오버라이딩 불가능

	 instance 메서드 : 오버라이딩 가능

========================================================================================================================================================================================================

☆추상클래스의 객체 생성 방법
		
		◇방법 1. 자식클래스를 만들어 상속시킨 뒤 객체생성
		
		abstract class 추상클래스1{
			abstract void abc();
		}
		
		class 추상클래스2 extends 추상클래스1 {
			void abc() {}
		}
		
		추상클래스1 추1 = new 추상클래스2();
		추상클래스2 추2 = new 추상클래스2();
		
		◇방법 2. 익명이너클래스 사용
		
		abstract class 추상클래스3{
			abstract void abc();
		}
		 
		추상클래스3 추3 = new 추상클래스3() {
			void abc() {} 			미완성 메서드를 이 메서드로 완성하여 추3의 객체 생성
		};                    세미콜론 들어가야 함
		
		방법 1은 상속받은 추상클래스2를 직접 정의해서
		이후에 여러개의 객체를 만들어야 한다면 유리하고
		
		방법 2는 클래스를 추가로 만들지 않아도 되지만
		익명이기에 클래스 이름을 몰라서 객체생성하려면 내용을 계속 정의해줘야 함
		한번만 쓰고 말것이라면 코드가 간결해 유리하다

		추상메서드를 하나도 포함하지 않아도 추상클래스로 정의는 가능하지만 할 이유는 없다

========================================================================================================================================================================================================

◇인터페이스의 default메서드 : 인터페이스 내부의 완성된 메서드
		오버라이딩 가능
		[필요에 의해 추가된 메서드이다]
		인터페이스에 그냥 abstrack 메서드를 추가하게되면 그 인터페이스를 구현한 모든 class가 오류나게 된다
		왜냐하면 class를 수정하기도 전에 미완성인 메서드가 들어갔기 때문

		◇작성 방법 : 부모인터페이스이름.super.디폴트메서드이름
					 그냥 super.디폴트메서드이름 하면 상위클래스인 Object 클래스 내부에서 메서드를 찾음
========================================================================================================================================================================================================

☆Thread의 속성 
	
	◇객체 가져오기
		현재 쓰레드 객체를 가르키는 참조값을 알고싶을때
			static Thread Thread.currentThread() 사용
				main같이 내가 직접만든 쓰레드 객체가 아니라면 참조값이 없기 때문에 커런트쓰레드 사용
				단순히 실행만 시키고 싶다면 약식으로 (new Thread()).start() 라고 쓰기도 함
	
	◇이름 지어주기 및 가져오기
		String setName(String name) : 지어준적이없으면 자동으로 작성됨 Thread-0 ,Thread-1,Thread-2
		String getName()
	 
	◇개수
		실행중인 쓰레드개수 가져오기
			static int Thread.activeCount()  : 현 시점에서 실행되고있는 같은 그룹내의 쓰레드 개수
	
	◇우선순위
		Thread의 우선순위(priority) 가져오기   : Thread클래스의 인스턴스 메서드
			int getPriority()
		
		Thread 객체 우선순위 정하기 : Thread클래스의 인스턴스 메서드
			void setPriority(int priority)
				10:가장높음   5:디폴트값  1:가장낮음
	
	◇데몬설정
		Thread 클래스의 인스턴스 메서드
			void setDemon(boolean on)
				on이 true인 경우    : demon Thread
				Default 값은 false : 일반 Thread
			
			일반쓰레드는 주 쓰레드 종료여부와 상관없이 자신의 쓰레드가 종료되어야 프로세스 종료
			데몬쓰레드는 일반쓰레드(사용자쓰레드)가 모두 종료되면 작업이 완료되지 않았어도 함께 종료
			
			주의 : setDemon()은 반드시 start()전에 호출

========================================================================================================================================================================================================

☆제네릭 : 하나의 클래스에 모든 타입을 담음
				클래스 내에서 사용되는 타입을 클래스의 정의가아닌 객체 생성때 정의하겠다는 의미
	
	◇제네릭의 필요성
		1.각각의 상품을 클래스로 만들면 새로 상품이 추가될 때 마다 새로운 클래스를 만들어야한다
		2.그럼 최상위 클래스인 object타입으로 만들면 그러면 모든타입을 넣을 수는 있지만 
		   그럴때마다 잘못된 타입을 캐스팅을 하게되면 나중에 실행시 발생할 수 있는 예외를 사전에 막을 수 없다
	
	◇제네릭의 문법
		접근지정자 class 클래스명 <T,K,V,N,E>{      }
		접근지정자 interface 클래스명 <T,K,V,N,E>{      }
	
			◇제네릭 타입의 변수    :  아무렇게나 작명해도 되지만 관례를 따른다
						T : 타입
						K : 키
						V : 값
						N : 숫자
						E : 원소

========================================================================================================================================================================================================

☆☆☆컬렉션 프레임워크☆☆☆
	◇컬렉션
		동일한 타입을 묶어서 관리하는 자료구조
		저장 공간의 크기(capacity)를 동적으로 관리
		배열과 동일한타입을 묶는다는것은 비슷하지만 배열은 생성시 크기를지정하고 추후 변경 불가
	
	◇프레임
		클래스와 인터페이스의 모임(라이브러리)
		클래스의 정의에 설계의 원칙 또는 구조가 존재
	
	◇컬렉션 프레임워크
		리스트,큐,스택,트리 등의 자료구조에 정렬,탐색 등의 알고리즘을 구조화 해 놓은 프레임워크
	
				  .............................................................................. 

☆List<E> 컬렉션의 공통 특성
	동일한 타입의 객체 수집(collection)
	메모리 동적 할당
	데이터의 추가,변경,삭제등의 메서드
		
		List<E> : 인터페이스
		1.ArrayList<E>     	:       구현class
		2.Vector<E>			:       구현class
		3.LinkedList<E>		:       구현class

		◇List<E>의 구현객체 정리 
		ArrayList<E>
			저장 용량 자동 추가
			인덱스로 요소 관리
		Vector<E>
			ArrayList와 동일한 특징
			내부 메서드 동기화 적용 : 멀티쓰레드 안전성
		LinkedList<E>
			앞뒤 요소로 정보 데이터 위치 관리
			추가 삭제 속도 빠름
			인덱스 정보가 없어 검색 느림

		◇List<E> 컬렉션의 특징
				  배열처럼 수집한 원소를 인덱스로 관리
	
		◇List<E> 인터페이스의 주요 메서드
				데이터 추가 : add , addAll : 매개변수로 입력된 컬렉션 전체를 마지막에 추가 
				데이터 변경 : set
				데이터 삭제 :	remove
				void  		 : 전체 원소 삭제

				리스트 정보 추출
				get
				size
				isEmpty   :   리스트 데이터가 하나도 없는지 여부를 리턴

				리스트 배열 반환
				toArray() : 입력받은 매개변수를 배열로 변환

	        ..............................................................................

☆Set<E>의 공통 특성
	
	List와 동일하지만 index정보가 없기때문에 한 주머니에 순서없이 담는다라고 생각해야 함
			@중요 : 중복을 허용하지않음 - HashCode로 판별
			@중요 : Set은 중복된 데이터를 가질 수 없다
 					  	  그럴려면 중복이 되지않는 판단기준이 있어야함
						  그때 사용하는것이 Hash관점에서 두개가 같은지 다른지 비교해서 중복확인 매커니즘을 만듬
						  매커니즘은 HashCode가 동일해야하고 equals()가 true가 나와야함
						  Hash라는 것이 들어가는 모든 자료구조가 이 메커니즘을 사용함	

	Set<E> : 인터페이스
		1.HashSet<E>		:       구현class                입력한 순서와 출력순서가 같지 않음
		2.LinkedHashSet<E>  :       구현class				 입력한 순서대로 출력
		3.TreeSet<E>        :       구현class				 반드시 크기비교가 가능한 것이여야 한다
	
========================================================================================================================================================================================================

		Map<K,V> : 인터페이스
		1.HashMap<K,V>		  :       구현class 	         입력순서와 출력순서는 동일하지 않을 수 있음
		2.LinkedHashMap<K,V>  :       구현class				 입력한 순서대로 출력
		3.HashTable<K,V>      :       구현class   		 	 헤쉬맵과동일 멀티쓰레드에서 안전
		4.TreeMap<K,V>        :       구현class				 입력순서와 상관없이 오름차순 정렬 ☆비교기준이 제공되어야 함


☆Map<K,V> 컬렉션의 특징
			Key 와 Value 의 한 쌍(Entry)으로 데이터를 저장
			Key는 중복저장 [불가] , Value는 중복저장 [가능]
				Key가 다르다면 동일한 값을 구분하여서 가져올 수 있음 : 인덱스와 같은 원리
			Collection과는 별개의 interface임 (List 와 Set 과 기본메서드부터 다름)
		 
		HashMap< K , V >
			Map< K , V >인터페이스를 구현한 대표적인 구현클래스
			입력순서와 출력순서는 동일하지 않을 수 있음 (Key값이 Set으로 관리)
		
		Map<Integer, String> hMap1 = new HashMap<Integer, String>();

		#1. put (K key , V value)
			Map은 Key값이 Set으로 관리되기 때문에 HashMap은 HashSet으로 관리됨
			그렇기에 출력시 어떤것 부터 나올지 알 수 없음
			key값은 인덱스가 아니기때문에 100,200 아무렇게나 해도 됨

		#2. PutAll(다른 맵 객체) : 다른 객체를 통째로 집어 넣음
		Map<Integer, String> hMap2 = new HashMap<>();
		hMap2.putAll(hMap1);
		
		#3-1. replace (K key , V value)
		
		#3-2. replace (K key , V oldValue, V newValue)
			해당 키와 해당 올드벨류가 완벽하게 일치할 때만 동작
		
		#4. V get(Object key) : 데이터 가져오기
		System.out.println(hMap2.get(1)); //@주의 : 인덱스 정보가 아니라 key값임
		System.out.println(hMap2.get(2)); //@주의 : 인덱스 정보가 아니라 key값임
		System.out.println(hMap2.get(3)); //@주의 : 인덱스 정보가 아니라 key값임
		
		#5-1. containsKey(Object key) : 해당 키값이 있는가?
		#5-2. containsKey(Object value) : 해당 밸류값이 있는가?
		
		#6-1. Set<K> keySet() : 키값을이용하여 Set객체를 만들어줌
		Set<Integer> keySet = hMap2.keySet();
		
		#6-2. Set<Map.Entry<K,V>> entrySet()
			Map.Entry<K,V>이 유형 데이터를 가지는 Set객체가 리턴됨
		Set으로 출력하므로 []로 출력됨 Map은 {}로 출력됨
		
		#7. size()
		
		#8-1. remove(Object key)
			List는 인덱스로 지우고
			Set은 오브젝트로 지우고 
			Map은 Key | Key Value로 지운다
		
		#8-2. remove(Object key , Object value)
		
		#9 clear()

========================================================================================================================================================================================================

☆☆☆ 객체의 타입변환(업,다운 캐스팅) ☆☆☆

		◇상속관계에 있는 경우 객체도 타입변환이 가능
			업캐스팅은 항상 가능
			다운캐스팅은 때에 따라서 가능/불가능 : 가능한 경우에만 수동으로 직접 캐스팅 필요

								A <- B <- C
 업캐스팅(자동타입변환)                                 다운캐스팅(수동타입변환)
   B b = new B();										A a = new A();
 		//B()까지 만들고 B객체를 가리킴 					    //A까지만 만듬
   A a = b;											    B b = (B) a;    //오류 발생
	    //부모인 A객체를 가르켜도 사용가능						 //바운더리를 A로 잡아놨기때문에 B객체는 존재하지 않음
   C c = new C();										A a = new B();
	    //C까지 만듬										   //B까지 만들고 A객체 만듬
   B b = c;											    B b = (B) a;    //OK
	    //C까지 만들었으니 그안에있는 B사용 가능			     //B까지 만들었기 때문에 다운캐스팅 가능 
   A a = c;												C c = (C) a;    //오류 발생
															  //C까지 안만듬	

		◇다운캐스팅 가능 여부 확인

		A a = new B();					 A a = new A();

				//true                        //false
		if (a instanceof B){          	 if(a instanceof B){  
			B b = (B)a;    					B b = (B)a;
		}								 }

========================================================================================================================================================================================================
A <- B <- C

☆ this. 와 this()
 
		◇ this.  : B는 A의 메서드를 오버라이딩했다 아무것도 안붙이고 메서드를 호출하면 컴파일러가 자동으로 this.을 붙여준다
					이때 호출되는 메서드는 B의 메서드이다

		◇ this() : 자신의 생성자를 호출     생성자 내부에서만 사용 가능    반드시 생성자 첫줄에 위치하여야 함
		    	    자식클래스 생성자의 첫 줄에는 반드시 this() 또는 super()가 포함되어야 함 [생략시 컴파일러가 자동 추가]
				    만약 자신의 생성자가 매개변수를 받는 생성자라면 this(매개변수)를 지정해줘야함


☆ super. 와 super()
 
		◇ super. : B는 A의 메서드를 오버라이딩했다 아무것도 안붙이고 메서드를 호출하면 컴파일러가 자동으로 this.을 붙여준다
				    super.을 붙여주면 부모의 메서드를 호출한다
					쓰는 이유는 부모메서드에 1000줄의 코드가 있는데 한줄만 추가하고 싶다면 super.부모메서드()하고 한줄의 코드만 더 써주면
					오버라이딩이 완료 된다

		◇ super(): 부모의 생성자를 호출    생성자 내부에서만 사용 가능    반드시 생성자 첫줄에 위치하여야 함
					자식클래스 생성자의 첫 줄에는 반드시 this() 또는 super()가 포함되어야 함 [생략시 컴파일러가 자동 추가]
					만약 부모의 생성자가 명시적으로 매개변수를 받는생성자로 되어있다면 기본생성자를 호출하는 super()는 에러

========================================================================================================================================================================================================

☆예외 및 예외 처리
		◇일반예외 : 예외처리를 하지 않으면 컴파일 자체가 불가능
		◇실행예외 : 예외처리 하지 않아도 컴파일은 가능 실행중 예외가 발생하면 프로그램 종료

		예외처리를 한다면 정상 실행 가능

		try {
			일반/실행 예외 발생 코드
			System.out.println(3/0);
			
		} catch (예외클래스이름 참조변수명) {
			예외가 발생한 경우 처리 블록
			만약 JVM에서 생성된 예외객체를 받을 수 잇는 catch블록이 없을 경우 예외처리가 되지 않음
			System.out.println("숫자는 0으로 나눌 수 없습니다");
		}final{
			예외 발생 여부 상관없이 무조건 실행 블록 
			생략 가능
			System.out.println("프로그램 종료");
		}

☆예외의 전가 : throws
		◇예외처리를 자신이 호출된 지점으로 전가 [이 경우 예외처리는 전가받은 상위위치에서 처리한다]
			메서드이름(...) throws 예외클래스

		◇상위 메서드들이 예외를 처리하지않고 전가만한다면 JVM이 처리하고 프로그램 죽음

========================================================================================================================================================================================================

☆인터페이스 : 인터페이스는 추상메서드와 마찬가지고 붕어빵기계를 만드는 기계라고 생각하면 된다

		◇상속 시 접근지정자는 좁아질 수 없다
		◇다중 상속 가능
		
		interface A {}       interface B {}
                                                        
		     class C implements A,B{}

	    ◇클래스와 인터페이스 동시에 상속,구현 가능

		Class A{}      interface B{}      interface C{}

		Class D extends A implements B,C {}   =  익스텐즈와 임플리먼트는 순서가 바뀔수 없다

tip: 동일한 타입을 상속시 extends
	 다른 타입을 상속하는 경우 implements
				그러나 인터페이스 implements 클래스 {} 는 불가능하다 : 완성된것을 미완성으로 만드는 꼴


